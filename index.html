<!doctype html>
<html>
<head>
  <title>reason.js</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='reason.js, reason, javascript, dependent types, formal verification, proofs'>
  <meta name='description' content='A library for dependent types in Javascript, with the power to formally verify properties on typed objects.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
    @font-face {
      font-family: 'sketchblock';
      src: url('fonts/SketchBlock.woff') format('woff2'),
           url('fonts/SketchBlock.woff2') format('woff2');
      font-weight: normal;
      font-style: normal
    }
    @font-face {
      font-family: 'crimson';
      src: url('fonts/Crimson.woff')  format('woff'),
           url('fonts/Crimson.woff2') format('woff2');
      font-weight: normal;
      font-style: normal
    }
    @font-face {
      font-family: 'crimson';
      src: url('fonts/Crimson-Bold.woff')  format('woff'),
           url('fonts/Crimson-Bold.woff2') format('woff2');
      font-weight: bold;
      font-style: normal
    }
    @font-face {
      font-family: 'crimson';
      src: url('fonts/Crimson-Italic.woff')  format('woff'),
           url('fonts/Crimson-Italic.woff2') format('woff2');
      font-weight: normal;
      font-style: italic
    }
    @font-face {
      font-family: 'univers';
      src: url('fonts/UniversNextTypewriter.woff')  format('woff'),
           url('fonts/UniversNextTypewriter.woff2') format('woff2');
      font-weight: normal;
      font-style: normal
    }
    body {
      margin: 4vh 25vw 0 15vw;
      background: url(images/bg.png);
      min-height: calc(100vh - 8vmin);
      color: #fff;
      font-size: 18px;
      border-top: 10px solid white }
    section {
      clear: right;
      margin-bottom: 14vmin }
    section:first-child p {
      font-variant: small-caps;
      padding: 0 3rem }
    h1 {
      font-family: 'sketchblock';
      font-weight: normal;
      margin: 2vmin 4vmin 5vmin 0;
      font-size: 4rem }
    h2 {
      font-family: 'crimson';
      font-size: 2.4rem;
      margin: 0 4vmin 3vmin 0 }
    p {
      font-family: 'crimson';
      font-size: 1.6rem;
      margin: 3vmin 0 4vmin 0;
      line-height: 2.4rem;
      text-align: justify }
    aside {
      margin: 0 -15vw 4vh 4vw;
      width:  35vw;
      height: 25vw;
      float: right;
     }
    iframe {
      width: 100%;
      height: 100%;
      border: 0 }
    .cut-in {
      margin: 4vh -15vw 27vh 4vw;
      --top: 15rem;
      --width: 35vw;
      --height: 30rem;
      --bottom: 100vh;

      width:  var(--width);
      height: var(--height);
      transform: translate(0, var(--top));
      shape-outside: polygon(0 var(--top), var(--width) var(--top), var(--width) var(--bottom), 0 var(--bottom));
      clip-path: polygon(0 0, var(--width) 0, var(--width) calc(var(--bottom) - var(--top)), 0 calc(var(--bottom) - var(--top)))
    }
    a {}
    strong {}
    em {}
    code {
      font-family: 'univers';
      font-variant-ligatures: none;
      font-size: 1.3rem;
      background: #fff2;
      --border: .4rem;
      padding: var(--border);
      margin: calc(- var(--border)) }
    blockquote {}
  </style>
  <script src='reason.js' defer></script>
  <script src='machine.js'></script>
</head>
<body>
  <main>
    <section>
      <h1>reason.js</h1>
      <p>A library for dependent types in Javascript, with the power to formally verify properties on typed objects.</p>
    </section>
  </main>
  <template id='editor'
    ><html>
      <head>
        <style>
          @font-face {
            font-family: 'univers';
            src: url('fonts/UniversNextTypewriter.woff')  format('woff'),
                 url('fonts/UniversNextTypewriter.woff2') format('woff2');
            font-weight: normal;
            font-style: normal
          }
          html {
            margin: 0;
            --x: 10px;
            font-size: 16px }
          body {
            margin: 1px 2px 1px 1px;
            overflow: hidden;
            background: #0008;
            color: #fff }
          main {
            display: grid;
            width: 100%;
            grid-gap: 1px }
          #source, #log {
            width: calc(100vw - 2 * var(--x) - 2px);
            height: calc(50vh - 2 * var(--x) - 1.5px);
            box-shadow: 0 0 0 1px #666;
            padding: var(--x);
            line-height: 1.2rem }
          #source {
            border: 0;
            margin: 0;
            outline: 0;
            background: transparent;
            min-height: 5vh;
            max-height: 85vh;
            resize: vertical;
            font-size: inherit;
            font-family: 'univers';
            font-variant-ligatures: none;
            color: #fff }
          #log {
            font-family: 'univers';
            font-variant-ligatures: none;
            overflow-y: auto }
          button {
            position: absolute;
            top: 10px;
            right: 10px }
          hr {
            border: 0;
            height: 0;
            border-top: 1px solid #444 }
        </style>
        <script src='reason.js' defer></script>
      </head>
      <body>
        <main>
          <textarea id='source'>[]</textarea>
          <div id='log'></div>
        </main>
        <button id='run'>Run</button>
        <script type="text/javascript" defer>
          let sourceTextbox = document.getElementById('source'),
              logDiv = document.getElementById('log'),
              runButton = document.getElementById('run');
              adjustHeight = () => logDiv.style.height = window.innerHeight - 23 - sourceTextbox.offsetHeight + 'px',
              log = (...args) => {
                logDiv.childNodes.length && logDiv.appendChild(document.createElement('hr'));
                logDiv.appendChild(document.createTextNode(args.join(' '))) };
          new MutationObserver(adjustHeight).observe(sourceTextbox, { attributes: true, attributeFilter: [ "style" ] });
          runButton.addEventListener('click', () => eval(`(async () => { let R = Reason(); ${sourceTextbox.value} })().catch(e => log(e.message))`))
        </script>
      </body>
    </html
  ></template>
  <template id='section'
    ><section>
      <aside><iframe></iframe></aside>
    </section
  ></template>
  <script>
// Page state
// ['', [], [].join('\n'), true]
var app = new $.Machine({
  sections: [
    [['#Are you sure about that?#',

      `A sentiment expressed so well by the great Jonathan Cena, uncertainty is something that touches all of us. Contrary to what some may think, a computer program won't help you separate reality from fiction when it comes to affairs of heart, or of society at large, but a little boost of confidence in regards to things doing what they say on the label wouldn't go astray in this fast-paced modern world. I'm not about to tell you dependent types or formal verification will spell the end of test driven development, nor that my little summer project to write a programming language in Javascript is fit for use in anything more your own fun side projects. But if someone told you that there was a system within which the properties of a program written on the label were mathematically guaranteed to be true, that would make you want to see for yourself, wouldn't it?`,

      `So without further ado, I would like to introduce reason.js, an interpreter for my language, which has some nifty features I'm kind of proud of, as well as some others that are still works in progress. I have also included little Javascript sandboxes in each section so you can experiment with using features for yourself. Edit the source code in the upper half, then click run to see the results in the lower half. You can also move the divider up and down (the handle is on the right). Try it!`
    ], [
      `log('Welcome to my TED talk')`
    ].join('\n'), true
    ], [[
      `#Managing expectations#`,

      `Right off the bat, there are still some serious limitations with the current state of the project. Some of the most serious are a lack of strings and decimal numbers. While I have plans to incorporate at a later date things like these which seem absolutely mandatory in any programming language, the difficulty cuts to the heart of what this is all about. In a bog-standard programming language such as Javascript, if you want to use a string you might write \`\`let myString = 'sup';\`\`, and be good to go. But what if you want to make statements //about// the string? Or, about //strings// in general?`,

      `You might go, \`\`let myStrLen = myString.length;\`\`, and sure, this will give you a value of 3, which is the length of \`\`myString\`\`. But who is making these decisions? We're all just hoping that the person who programmed the \`\`length\`\` property made sure it was an integer, never negative, not off-by-one, and so on. You might call length a million times and get correct results every time, without ever discovering that if you call it on the string "never gonna give you up", the developer left an easter egg to print the entire lyrics to the console.`,

      `This has always been the allure of functional languages such as Scala, Haskell, or OCaml - only certain //types// are allowed to print to console, or return numerical values, or operate on any kind of value as long as it's a stream of them. Types have a rich mathematical structure that allows them to take on any form you care to come up with - however, types are limited by the language you use. Javascript is infamous for playing fast and loose with type coercion (try evaluating \`\`[[][[]]+[]][+[]][-~[]]\`\` for example, but there are a million more), so sometimes you just can't know if the \`\`false\`\` your function received is really a false, or whether it was an \`\`undefined\`\` or a \`\`null\`\` in a previous life.`,

      `So, if I want to define a type of strings, what do I need to know? Well, to oversimplify, a string can be encoded as a list of chunks of 8 binary digits. So now we need to define both binary digits, chunks of 8 of them, and lists of chunks.`,

      `... where am I going with this`
    ], [].join('\n'), false]
  ]
});

// Events
$.targets({
  load () { app.emit('load-editors') },
  app: { 'load-editors' () {
    this.sections.forEach(([ps, source, cutin]) => {
      let section = $.load('section', 'main')[0][0];
      for (let p of ps) write(p, section);
      if (typeof source === 'string' && source.length) {
        $('iframe', section)[0].srcdoc = $('template#editor')[0].innerHTML.replace(/\[\]/g, source);
        if (cutin) $('aside', section)[0].classList.add('cut-in');
      } else $('aside', section)[0].remove();
    })
  } }
});

// Oh god. Very old markup code I had lying around

function write (raw, section) {
  //  **bold**  //italic//  ``monospaced``  [[link url]]  [[link url|link text]]
  //  >quote (\>no quote)  ␣␣↵line break  ↵↵paragraph  #(#..)header#
  function escape (text) {
    var div = document.createElement("div");
    div.appendChild(document.createTextNode(text));
    return div.innerHTML
  }
  var r = escape(raw), newline = r.indexOf("\r\n") !== -1 ? "\r\n" : r.indexOf("\n") !== -1 ? "\n" : "";
  r = r
    .replace(new RegExp(" + " + newline, "g"), "<br />" + newline)
    .replace(/^(#{1,5})([^#]*)#/, function ($0, $1, $2) {
      var l = $1.length + 1;
      if (l === 2) {
        var slug = encodeURI( $2.replace(/\s+/g, "-").replace(/\*\*(.*)\*\*/g, "$1").replace(/``(.*)``/g, "$1")
          .replace(/^/," ").replace(/([^:])\/\/(((?!\/\/)[\s\S])*)\/\//gm, "$2").replace(/^ /,"")
          .replace(/\[\[([^\]|]*)\]\]/g, "$1").replace(/\[\[([^|]*)\|([^\]]*)\]\]/g, "$2")
          .replace(/[^\w\-.~!$&'()*+,;=:@]/g, "").toLowerCase() );
        return "<header><a class='hashlink' id='" + slug + "' href='#" + slug + "'></a><h2>" + $2 +
          "</h2></header>"
      } else return "<h" + l + ">" + $2 + "</h" + l + ">"
    })
    .replace(/``([^`]*)``/g, "<code>$1</code>")
    .replace(/\*\*([^*]*)\*\*/g, "<strong>$1</strong>")
    .replace(/^/," ").replace(/([^:])\/\/(((?!\/\/)[\s\S])*)\/\//gm, "$1<em>$2</em>").replace(/^ /,"")
    .replace(/\[\[([^\]|]*)\]\]/g, function ($0, $1) { return "<a href='" + $1.replace(/'/g, "&apos;") + "'>" + $1 + "</a>" })
    .replace(/\[\[([^|]*)\|([^\]]*)\]\]/g, function ($0, $1, $2) { return "<a href='" + $1.replace(/'/g, "&apos;") + "'>" + $2 + "</a>" });
  for (var p = (newline === "" ? [r] : r.split(newline + newline)), i = 0; i < p.length; i++) {
    p[i] = p[i]
      .replace(/^&gt;(.*)/g, "<blockquote>$1</blockquote>").replace(/^\\&gt;/g, "&gt;")
      .replace(/^( +)/g, function (match) { return match.replace(/\s/g,"&nbsp;") });
    p[i] = p[i].replace(/([\s\S]+)/g, "<p>$1</p>")
  }
  section.innerHTML += p.join(newline);
}

$.queries({})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>
