<!doctype html>
<html>
<head>
  <title>reason.js</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='reason.js, reason, javascript, dependent types, formal verification, proofs'>
  <meta name='description' content='A library for dependent types in Javascript, with the power to formally verify properties on typed objects.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
    @font-face {
      font-family: 'sketchblock';
      src: url('fonts/SketchBlock.woff') format('woff2'),
           url('fonts/SketchBlock.woff2') format('woff2');
      font-weight: normal;
      font-style: normal
    }
    @font-face {
      font-family: 'crimson';
      src: url('fonts/Crimson.woff')  format('woff'),
           url('fonts/Crimson.woff2') format('woff2');
      font-weight: normal;
      font-style: normal
    }
    @font-face {
      font-family: 'crimson';
      src: url('fonts/Crimson-Bold.woff')  format('woff'),
           url('fonts/Crimson-Bold.woff2') format('woff2');
      font-weight: bold;
      font-style: normal
    }
    @font-face {
      font-family: 'crimson';
      src: url('fonts/Crimson-Italic.woff')  format('woff'),
           url('fonts/Crimson-Italic.woff2') format('woff2');
      font-weight: normal;
      font-style: italic
    }
    @font-face {
      font-family: 'univers';
      src: url('fonts/UniversNextTypewriter.woff')  format('woff'),
           url('fonts/UniversNextTypewriter.woff2') format('woff2');
      font-weight: normal;
      font-style: normal
    }
    body {
      margin: 0;
      background: url(images/bg.png) }
    main {
      margin: 4vh 25vw 0 15vw;
      min-height: calc(100vh - 8vmin);
      color: #fff;
      font-size: 18px;
      border-top: 10px solid white }
    section {
      clear: right;
      margin-bottom: 14vmin }
    section:first-child p {
      font-variant: small-caps;
      padding: 0 3rem }
    h1 {
      font-family: 'sketchblock';
      font-weight: normal;
      margin: 2vmin 4vmin 5vmin 0;
      font-size: 4rem }
    h2 {
      font-family: 'crimson';
      font-size: 2.4rem;
      margin: 0 4vmin 3vmin 0 }
    p {
      font-family: 'crimson';
      font-size: 1.6rem;
      margin: 3vmin 0 4vmin 0;
      line-height: 2.4rem;
      text-align: justify }
    aside {
      margin: 0 -15vw 4vh 4vw;
      width:  35vw;
      height: 25vw;
      float: right;
     }
    iframe {
      width: 100%;
      height: 100%;
      border: 0 }
    body:not(.expanded) .cut-in {
      margin: 4vh -15vw 27vh 4vw;
      --top: 15rem;
      --width: 35vw;
      --height: 30rem;
      --bottom: 100vh;

      width:  var(--width);
      height: var(--height);
      transform: translate(0, var(--top));
      shape-outside: polygon(0 var(--top), var(--width) var(--top), var(--width) var(--bottom), 0 var(--bottom));
      clip-path: polygon(0 0, var(--width) 0, var(--width) calc(var(--bottom) - var(--top)), 0 calc(var(--bottom) - var(--top)))
    }
    a {
      color: inherit;
      text-decoration: inherit }
    strong {}
    em {}
    code {
      font-family: 'univers';
      font-variant-ligatures: none;
      font-size: 1.3rem;
      background: #fff2;
      --border: .4rem;
      padding: var(--border);
      margin: calc(- var(--border)) }
    blockquote {
      display: flex;
      background: #fff2;
      font-family: 'univers';
      font-variant-ligatures: none;
      padding: .4rem;
      word-break: break-all }
    .expand, .collapse {
      position: relative;
      bottom: calc(1.2rem + 10px);
      right: 5px;
      height: 1.2rem;
      fill: #fff;
      display: none;
      cursor: pointer;
      float: right }
    [data-active='active'] { display: block }
    body.expanded { overflow: hidden }
    body.expanded > main {
      width: calc(50% - 3rem);
      overflow-y: auto;
      height: 100vh;
      margin: 0;
      padding: 0 1.5rem }
    body.expanded aside {
      position: fixed;
      top: 0;
      right: 0;
      margin: 0;
      width: 50%;
      height: 100% }
    body.expanded aside { display: none }
    body.expanded aside.active { display: block }
  </style>
  <script src='reason.js' defer></script>
  <script src='machine.js'></script>
</head>
<body>
  <main>
    <section>
      <h1><a href='https://github.com/ajhamwood/reason'>reason.js</a></h1>
      <p>A library for dependent types in Javascript, with the power to formally verify properties on typed objects.</p>
    </section>
  </main>
  <template id='editor'
    ><html>
      <head>
        <style>
          @font-face {
            font-family: 'univers';
            src: url('fonts/UniversNextTypewriter.woff')  format('woff'),
                 url('fonts/UniversNextTypewriter.woff2') format('woff2');
            font-weight: normal;
            font-style: normal
          }
          html {
            margin: 0;
            --x: 10px;
            font-size: 16px }
          body {
            margin: 1px 2px 1px 1px;
            overflow: hidden;
            background: #0008;
            color: #fff }
          main {
            display: grid;
            width: 100%;
            grid-gap: 1px }
          #source, #log {
            width: calc(100vw - 2 * var(--x) - 2px);
            height: calc(50vh - 2 * var(--x) - 1.5px);
            box-shadow: 0 0 0 1px #666;
            padding: var(--x);
            line-height: 1.2rem }
          #source {
            border: 0;
            margin: 0;
            outline: 0;
            background: transparent;
            min-height: 1.6rem;
            max-height: calc(100vh - 22px - 2rem);
            resize: vertical;
            font-size: inherit;
            font-family: 'univers';
            font-variant-ligatures: none;
            color: #fff }
          #log {
            font-family: 'univers';
            font-variant-ligatures: none;
            overflow-y: auto;
            word-break: break-all }
          button {
            position: absolute;
            top: 10px;
            right: 10px }
          hr {
            border: 0;
            height: 0;
            border-top: 1px solid #444 }
        </style>
        <script src='reason.js' defer></script>
      </head>
      <body>
        <main>
          <textarea id='source'>[]</textarea>
          <div id='log'></div>
        </main>
        <button id='run'>Run</button>
        <script type="text/javascript" defer>
          let sourceTextbox = document.getElementById('source'),
              logDiv = document.getElementById('log'),
              runButton = document.getElementById('run'),
              adjustHeight = () => logDiv.style.height = window.innerHeight - 23 - sourceTextbox.offsetHeight + 'px',
              log = (...args) => {
                logDiv.childNodes.length && logDiv.appendChild(document.createElement('hr'));
                logDiv.appendChild(document.createTextNode(args.join(' '))) };
          new MutationObserver(adjustHeight).observe(sourceTextbox, { attributes: true, attributeFilter: [ "style" ] });
          runButton.addEventListener('click', () => Promise.resolve()
            .then(() => eval(
              `(async () => {` +
              `  let R = Reason();` +
              `  ${sourceTextbox.value}` +
              `})()` +
              `  .catch(e => log(e.message))` +
              `  .then(() => document.getElementById('log').scrollTo(0, 1e6))`))
            .catch(e => log(e.message)))
        </script>
      </body>
    </html
  ></template>
  <template id='section'
    ><section>
      <aside>
        <iframe></iframe>
        <svg class='expand' viewBox="0 0 1000 1000" data-active='active'>
          <path d="M310.1,990H10V689.9l98-98v220.5l196-196l79.6,79.6l-196,196h220.5L310.1,990z M990,689.9V990H689.9l-98-98h220.5l-196-196l79.6-79.6l196,196V591.9L990,689.9z M689.9,10H990v300.1l-98,98V187.6l-196,196L616.4,304l196-196H591.9L689.9,10z M10,310.1V10h300.1l98,98H187.6l196,196L304,383.6l-196-196v220.5L10,310.1z"/>
        </svg>
        <svg class='collapse' viewBox="0 0 1000 1000" data-active=''>
          <path d="M893.2,403.2H596.8V106.8L693.6,10v217.8L887.2,34.2l78.6,78.6L772.2,306.4H990L893.2,403.2z M403.2,106.8v296.4H106.8L10,306.4h217.8L34.2,112.8l78.6-78.6l193.6,193.6V10L403.2,106.8z M106.8,596.8h296.4v296.4L306.4,990V772.2L112.8,965.8l-78.6-78.6l193.6-193.6H10L106.8,596.8z M596.8,893.2V596.8h296.4l96.8,96.8l-217.8,0l193.6,193.6l-78.6,78.6L693.6,772.2V990L596.8,893.2z"/>
        </svg>
      </aside>
    </section
  ></template>
  <script>
// Page state
var app = new $.Machine({
  sections: [
    [[
      `#Are you sure about that?#`,
      ``,
      `A sentiment expressed so well by the great Jonathan Cena, uncertainty is something that touches all of us. Contrary to what some may think, a computer program won't help you separate reality from fiction when it comes to affairs of heart, or of society at large, but a little boost of confidence in regards to things doing what they say on the label wouldn't go astray in this fast-paced modern world. I'm not about to tell you dependent types or formal verification will spell the end of test driven development, nor that my little summer project to write a programming language in Javascript is fit for use in anything other than your own fun side projects. But if someone told you that there was a system within which the properties of a program written on the label were mathematically guaranteed to be true, you would want to see for yourself, wouldn't you?`,
      ``,
      `So without further ado, I would like to introduce reason.js, an interpreter for my language, which has some nifty features I'm kind of proud of, as well as some others that are still works in progress. I have also included little Javascript sandboxes in each section so you can experiment with using features for yourself. Edit the source code in the upper half, then click run to see the results in the lower half. You can also move the divider up and down (the handle is on the right). Try it!`
    ].join('\n'), [
      `let identity = new R.Def(`,
      `  "id", "({t} , x => x) : {T : Type} -> T -> T"`,
      `);`,
      ``,
      `await R.ready;`,
      ``,
      `log(identity.print);`,
      `log(identity.type.print())`
    ].join('\n'), true
    ], [[
      `#Installation#`,
      ``,
      `It's in the books to publish reason.js to npm, but for now you can simply clone master:`,
      ``,
      `>$ git clone --depth 1 -b master https://github.com/ajhamwood/reason`,
      ``,
      `If you then include the file \`\`reason.js\`\` in the root directory of your project, you will be able to access the interpreter by calling \`\`const R = Reason()\`\`.`
    ].join('\n'), [].join('\n'), false
    ], [[
      `#Interpreter#`,
      ``,
      `The workhorse of reason.js are the methods \`\`Sig\`\`, \`\`Def\`\` and \`\`Data\`\` on the object you just initialised. They can be used to initialise types, type constructors, type signatures, and functions, which are all you need to access the full power of dependent types.`,
      ``,
      `Let's start off with \`\`Def\`\`, which creates term definitions. The identity function for example can be encoded likewise:`,
      ``,
      `>let identity = new R.Def(`,
      `>  "id", "(t , x => x) : (T : Type) -> T -> T"`,
      `>);`,
      ``,
      `Let's break that down. The string argument encodes the term that will be interpreted, checked that it conforms to the typing rules of the language, and then attached to the Javascript class being instantiated. The actual syntax will be described later on; for now, we will focus on the Javascript. Although this example will return near-instantaneously, some type checks may be more computationally intensive to run. To deal with this, the \`\`identity\`\` object initially has only four properties of note: \`\`appliedTerms\`\`, \`\`toString\`\`, and \`\`ready\`\` and \`\`name\`\` (\`\`length\`\` is a property on all JS functions). Here we are interested in that last one: it returns a promise containing the typechecked object. So, if you run the following code within an \`\`async\`\` function, the results will be available immediately afterwards:`,
      ``,
      `>let identity = await new R.Def(`,
      `>  "id", "(t , x => x) : (T : Type) -> T -> T"`,
      `>).ready;`,
      ``,
      `For convenience, the reason.js object also has this property, so you can call \`\`await R.ready;\`\` to pause at any moment until the typecheck has completed.`,
      ``,
      `This time, we get four additional properties: \`\`type\`\`, \`\`term\`\`, \`\`print\`\`, and \`\`result\`\`, and we are now ready to consider the API on term definitions as a whole.`
    ].join('\n'), [
      `let identity = new R.Def(`,
      `  "id", "(t , x => x) : (T : Type) -> T -> T"`,
      `);`,
      ``,
      `log(Object.getOwnPropertyNames(identity));`,
      ``,
      `await R.ready;`,
      ``,
      `log(Object.getOwnPropertyNames(identity))`
    ].join('\n'), true
    ], [[
      `#Term definitions#`,
      ``,
      `First, let's look at the immediately available properties.`,
      ``,
      `\`\`ready\`\` we have already seen. It returns a \`\`Promise\`\` containing the asynchronously-available term object.`,
      ``,
      `\`\`name\`\` is an easy one: this is the identifier the term has been declared as. In the above example, its value would be \`\`"id"\`\`.`,
      ``,
      `In our example, \`\`appliedTerms\`\` would return an empty list. However as the name suggests, if you were to //apply// terms to a typechecked function, the results would be available here. We could even apply id to itself, like so:`,
      ``,
      `>let idType = new R.Def(`,
      `>      "idType", "((T : Type) -> T -> T) : Type"`,
      `>    ),`,
      `>    idid = identity(idType, identity);`,
      ``,
      `You would then find \`\`appliedTerms\`\` to be equal to \`\`[ idType, identity ]\`\`. However, if you used the in-page sandbox for this section, the log would instead display \`\`<idT>,<id>\`\`. This is because the \`\`toString\`\` function on terms returns the supplied term name within angle brackets by default. In the section on converters, we will cover how to define your own string coercion function, but for now you can consider it as almost the same as \`\`name\`\`.`,
      ``,
      `Now for the asynchronously available properties.`,
      ``,
      `\`\`print\`\` returns a string representing the term. It should be quite similar to the expression you supplied on instantiation, but the variables will be renamed to generic x's, y's and z's. (There may still be some printing bugs for me to squash, please report it if you find one!)`,
      ``,
      `\`\`term\`\` and \`\`type\`\` contain the internal representation of the typechecked term and type respectively. You may not find much use for them yet, but it might be interesting to execute their \`\`toString\`\` methods!`,
      ``,
      `Finally, \`\`result\`\` contains the result of evaluating the term. Comparing \`\`idid.print\`\` and \`\`idid.result.print()\`\` will illustrate the work the typechecker actually performed on the supplied term.`
    ].join('\n'), [
      `let identity = new R.Def(`,
      `      "id", "(t , x => x) : (T : Type) -> T -> T"`,
      `    ),`,
      `    idType = await new R.Def(`,
      `      "idT", "((T : Type) -> T -> T) : Type"`,
      `    ).ready,`,
      `    idid = await identity(idType, identity).ready;`,
      ``,
      `log(idid.result.print())`
    ].join('\n'), true
    ], [[
      `#Signature definitions#`,
      ``,
      `The next constructor method we will look at is \`\`Sig\`\`, which creates signature definitions that a term can be typechecked against. This is needed because not all definitions can fit snugly on a single line as our examples so far have. However, for simplicity let us return to our identity function example. It was given in //annotated form//, which is when term and type information are given together, and has the syntax \`\`term : type\`\`. Thus the term part is \`\`t, x => x\`\`, while the type part is \`\`(T : Type) -> T -> T\`\`. You may notice that this type signature also contains a colon, and indeed there is another type annotation, this time occurring within a term rather than at the end. It says that the \`\`T\`\`, wherever it occurs afterwards in the type term, has type \`\`Type\`\`.`,
      ``,
      `To declare the signature part of our definition on its own, we can write:`,
      ``,
      `>let identity = new R.Sig(`,
      `>  "id", "(T : Type) -> T -> T"`,
      `>);`,
      ``,
      `Now if we have a look at the properties, we get \`\`Def\`\`, \`\`name\`\` and \`\`ready\`\`  available immediately, and \`\`type\`\`, \`\`print\`\` and \`\`result\`\` available asynchronously. This is different to what we had for term definitions: the \`\`term\`\` property is missing for obvious reasons, and since it is a signature, it cannot be applied and thus we don't need \`\`appliedTerms\`\` (the jury is still out on whether I will add \`\`toString\`\` later on). The new \`\`Def\`\` property is suggestive, and as you might guess, it is used to chain a term definition to our signature object. We will look at it in more detail a little later, when we have some more interesting terms at our disposal.`
    ].join('\n'), [
      `let identity = new R.Sig(`,
      `  "id", "(T : Type) -> T -> T"`,
      `);`,
      ``,
      `log(Object.getOwnPropertyNames(identity));`,
      ``,
      `await R.ready;`,
      ``,
      `log(Object.getOwnPropertyNames(identity))`
    ].join('\n'), true
    ], [[
      `#Data definitions#`,
      ``,
      `As you may be beginning to realise, there is only so far we can go with function terms. Or, I should rephrase, want to go. As Church's famous theorem tells us, if we have functions, we can encode pretty much any mathematical structure we like. Unfortunately, Church encodings of even basic things like numbers or Booleans are highly unwieldy, and we already have types available. So let us now define our first real type:`,
      ``,
      `>let Void = new R.Data("Void", "Type", []);`,
      ``,
      `It's... not much. This type corresponds to the bottom type **⊥** in type theory, and is characterised as a type without any terms. We can see that it has a name field, a type field, as well as something new as an empty array. This something new is necessary because types are potentially //constructible//, so we need to be able to define the ways in which they can be constructed. The simplest constructible type, corresponding to the top type **⊤**, can be defined like this:`,
      ``,
      `>let Unit = new R.Data(`,
      `>      "Unit", "Type",`,
      `>      [ "TT : Unit" ]`,
      `>    );`,
      ``,
      `In the list of constructors, we now have a the single constructor \`\`TT\`\` often seen represented as **()**, with a type annotation that says it is of type \`\`Unit\`\`. While you might guess that type constructors always have the type of the type constructor, that is not always the case, as we will see in the section on indexed types.`,
      ``,
      `If we have a look at the properties on the object, this time they aren't as helpful: just \`\`name\`\` and \`\`ready\`\`. So, how do we use it? Conceptually, both type constructors and term constructors can be formed using zero or more arguments, so in that sense they are like functions. Thus in Javascript we also instantiate our usable typed objects from the \`\`Data\`\` class by executing them, like so: \`\`Unit()\`\`. Now if we view the properties after waiting for typecheck, we find a bunch more: on \`\`Void()\`\` we have the familiar \`\`appliedTerms\`\`, \`\`type\`\`, \`\`term\`\`, \`\`print\`\` and \`\`toString\`\`, along with a new method \`\`fromJS\`\`, and on \`\`Unit()\`\` we also have a property generated from our data definition: \`\`tt\`\`. \`\`fromJS\`\` is a coercion method which will be explored later, so for now let's look at \`\`tt\`\`.`,
      ``,
      `The unapplied object has even less properties now, missing \`\`ready\`\` because if we have access to \`\`tt\`\` the type constructor has already been typechecked. The asynchronous object is now missing \`\`tt\`\` and \`\`fromJS\`\`, but has gained a new property \`\`result\`\` which were are familiar with already.`,
      ``,
      `With the API now sorted, we can turn our attention to the star attraction: the expression syntax.`
    ].join('\n'), [
      `let Void = new R.Data("Void", "Type", []),`,
      `    Unit = new R.Data("Unit", "Type", [ "TT : Unit" ]);`,
      ``,
      `log(Object.getOwnPropertyNames(Void));`,
      `log(Object.getOwnPropertyNames(Unit));`,
      ``,
      `await R.ready;`,
      ``,
      `log(Object.getOwnPropertyNames(Void()));`,
      `log(Object.getOwnPropertyNames(Unit()));`,
      `log(Object.getOwnPropertyNames(Unit().tt()))`
    ].join('\n'), true
    ],[[
      `#Expressions#`,
      ``,
      `Since our identity function example is starting to wear a little thin, let's define a new, highly useful type that appears just about everywhere: the natural numbers. To be precise, these are the peano numerals, otherwise known as unary numbers.`,
      ``,
      `>let Nat = new R.Data(`,
      `>  "Nat", "Type",`,
      `>  [ "Z : Nat",`,
      `>    "S : (n : Nat) -> Nat" ]`,
      `>);`,
      ``,
      `In unary, numbers are defined by how many successors have been applied starting with zero. So for example the number three would be encoded as **S S S Z**. From our earlier \`\`Unit\`\` example, we can surmise that this type has two constructors, \`\`Z\`\` and \`\`S\`\` (which stand for zero and successor), and that \`\`Z : Nat\`\` should work like \`\`TT : Unit\`\`. But what is that arrow in the definition for \`\`S\`\`?`,
      ``,
      `The //dependent// part of dependent types (also known as //pi// types) refers to types which depend on terms found earlier. Just like the type variable \`\`T\`\` found in the identity function type, the \`\`n\`\` in the definition of \`\`S\`\` is allowed to appear freely to the right within that type term. So we can say that \`\`(n : Nat) -> Nat\`\` is a type term. What does it mean to be "to the right"? That's simple enough: it means anywhere after the next \`\`->\`\`. Finally, to answer what an arrow is for: it defines the type of a //function//. \`\`Nat -> Nat\`\` is then the type of all functions which take a \`\`Nat\`\` as an argument, and return a \`\`Nat\`\`. Note that it isn't only the type of \`\`S\`\`. It's the type of all such functions.`,
      ``,
      `So now that we know how to make the type of a function, what does a function look like? We saw one already, but let's define a new one using our \`\`Nat\`\` type: a function which adds two.`,
      ``,
      `>let addTwo = new R.Sig(`,
      `>  "addTwo", "Nat -> Nat" ).Def(`,
      `>    "n => S (S n)"`,
      `>);`,
      ``,
      `Now we have a new arrow: \`\`=>\`\`. This expresses a //lambda// function, which takes a single argument denoted by the identifier immediately to the left (\`\`n\`\` here), and returns a term according to the expression to the right. So, if the value of \`\`n\`\` is \`\`S Z\`\`,  this lambda will return \`\`S (S (S Z))\`\`. And indeed, 1 + 2 = 3.`,
      ``,
      `Now, you may be wondering what happens if you have a function which takes more than one argument? Well as it turns out, any such function can be converted into a series of nested functions, each of which consumes an argument and returns a function on one less argument. This is known as currying, after mathematician Haskell Curry. As a shorthand, you can write a lambda expression on many arguments by separating the bound variables with a comma, like so: \`\`x, y => x\`\`. Similarly in pi expressions, all but the final  arrow can be elided, however the bound variable must be identified: \`\`(x : A)(y : B) -> A\`\`.`,
      ``,
      `Finally, as a quick addendum to expressions for term definition, often the type annotation part is actually not required; it can be possible to let the typechecker infer the type for you.`
    ].join('\n'), [
      `let Nat = new R.Data(`,
      `      "Nat", "Type",`,
      `      [ "Z : Nat",`,
      `        "S : (n : Nat) -> Nat" ]`,
      `    ),`,
      ``,
      `    addTwo = new R.Sig(`,
      `      "addTwo", "Nat -> Nat" ).Def(`,
      `        "n => S (S n)"`,
      `    ),`,
      ``,
      `    one = new R.Def("one", "(S Z) : Nat");`,
      ``,
      `await R.ready;`,
      ``,
      `log(addTwo.print)`,
      `log(one.print);`,
      `log((await addTwo(one).ready).result.print())`
    ].join('\n'), true
    ], [[
      `#Converters#`,
      ``,
      `In Javascript, it is possible to define a default way that an object may be converted to both \`\`Number\`\` and \`\`String\`\` types: these are the \`\`valueOf\`\` and \`\`toString\`\` methods, respectively. In reason.js, the ability exists to define conversion of terms of any type to and from these or any other Javascript type. We have seen the default \`\`toString\`\` method on function terms with \`\`identity\`\` and datatype terms with \`\`Unit\`\`. Let's now have a go at defining our own coercion methods on Booleans:`,
      ``,
      `>let Boolean = new R.Data(`,
      `>      "Bool", "Type",`,
      `>      [ { "F : Bool": {} },`,
      `>        { "T : Bool": {} } ],`,
      `>      {}`,
      `>    );`,
      ``,
      `Even though this is only a skeleton for placing the coercion methods, right off the bat the arguments look different to before. Instead of an array of term constructor expression strings, the strings are now keys each in their own hash, with their value another hash. Well, as you might have guessed, this is where the methods on those constructors will go. Specifically, methods will be taken from here and used to convert reason.js terms to Javascript. Conversely, methods defined in that new hash argument at the end will be used to convert Javascript values to reason.js terms.`,
      ``,
      `In the case of Booleans, there is one clear strategy we can take: Javascript \`\`true\`\` can map to the term named \`\`T\`\`, and \`\`false\`\` to \`\`F\`\`. Let's start with the to-Javascript direction, using \`\`valueOf\`\` since \`\`true\`\` and \`\`1\`\`, etc., are pretty interchangeable in Javascript. In the case of \`\`F\`\` we could write the hash entry as \`\`valueOf: () => true\`\`, with something similar for \`\`false\`\`. In the opposite direction, we use the key \`\`fromJS\`\` and define a function taking a true-or-falsey value and returning a typed Bool object. Putting it all together, we have:`,
      ``,
      `>let Bool = new R.Data(`,
      `>      "Bool", "Type",`,
      `>      [ { "F : Bool": { valueOf: () => false } },`,
      `>        { "T : Bool": { valueOf: () => true } } ],`,
      `>      { fromJS: value => Bool()[value ? 't' : 'f']() }`,
      `>    );`,
      ``,
      `This is not the whole story on coercion; we will revisit them when we describe the special requirements for coercing to and from parametrised types in the next section.`
    ].join('\n'), [
      `let Bool = await new R.Data(`,
      `      "Bool", "Type",`,
      `      [ { "F : Bool": { valueOf: () => false } },`,
      `        { "T : Bool": { valueOf: () => true } } ],`,
      `      { fromJS: value => Bool()[value ? 't' : 'f']() }`,
      `    ).ready;`,
      ``,
      `log(Bool().fromJS([]).valueOf() && !Bool().fromJS('').valueOf())`
    ].join('\n'), true
    ], [[
      `#Parametrised types#`,
      ``,
      `In the section on data definitions, we mentioned that constructors can form terms using zero or more arguments, but didn't actually give any examples. Here is where we rectify that by introducing parametrised types, which is the official name for types formed with arguments. The simplest and canonical example is probably quite familiar to you: it's a list. Let's look at the data definition:`,
      ``,
      `>let List = new R.Data(`,
      `>      "List", "(A : Type) : Type",`,
      `>      [ "Nil : List A",`,
      `>        "Cons : (x : A)(xs : List A) -> List A" ]`,
      `>    );`,
      ``,
      `There is a little more going on here than there was for \`\`Nat\`\`, but let's break it down. This time the type constructor has a colon, but don't be fooled: it isn't an annotation at all because this field isn't a type signature, it's a type //constructor//. It serves to separate the parameters from the indexes (more on that in the next section), with the parameter here being the type variable \`\`A\`\`. This is the essence of a parametrised type: terms are constructed concretely //using// terms of other types, but it's defined in a generalised way. Next we can see it has two term constructors, \`\`Nil\`\` and \`\`Cons\`\` (this nomenclature goes way back to lisp and beyond). The type of \`\`Nil\`\` is \`\`List A\`\`, but wait - where does it get the \`\`A\`\` from?`,
      ``,
      `>let nilBool = new R.Def("nilBool", "Nil : List Bool");`,
      ``,
      `This example defines a list of \`\`Bool\`\` terms of zero length. Now, if you call a \`\`nilBool\`\`, it will know what kind of \`\`List\`\` it is because the parameter is there in the type signature. Still, why do we need to say what type of thing I have nothing of? Couldn't I just start adding terms on the end of any nil list? Well the answer to that hints at what makes strong typing so powerful: it limits what you can do in certain meaningful ways, so you can always work out what is supposed to go where, even if you have none right now. Anything could be added to the single kind of nil list Javascript has, \`\`[]\`\`, so often we need to extensively guard on incoming data - \`\`if (typeof value === "string") ...\`\`, blah blah blah. Strong typing obviates this class of cruft right out of the gate.`,
      ``,
      `Returning to the example, the other term constructor is \`\`Cons\`\` which appends terms of type \`\`A\`\` to the end of the list, so \`\`Cons Z (Cons (S Z) Nil) : List Nat\`\` would be equivalent to the Javascript array \`\`[1,0]\`\`. And speaking of equivalence, I promised a second part to coercion so let's look at that now.`,
      ``,
      `The issue with coercing to a parametrised type is that you may be able to construct for example the \`\`List\`\` part, but what about the \`\`A\`\`? We don't even know what type to construct. The solution here is to use the local scope and pull the necessary objects from \`\`this\`\`. In fact, for the reverse direction, we already had a problem coercing from recursive types like \`\`Nat\`\` to Javascript - questions like "what level of \`\`S\`\`s are we at right now?" can't be answered without some kind of state. So, let me give you one solution in the case of \`\`List\`\`:`,
      ``,
      `>let List = new R.Data(`,
      `>      "List", "(A : Type) : Type",`,
      `>      [ { "Nil : List A": { valueOf: () => [] } },`,
      `>        { "Cons : (x : A)(xs : List A) -> List A":`,
      `>          { valueOf () {`,
      `>            return this[1].valueOf()`,
      `>              .concat([ this[0].valueOf() ]) } }`,
      `>        } ],`,
      `>      { fromJS (value) {`,
      `>        let p = () => value.length === 0 ?`,
      `>              this.nil() :`,
      `>              this.cons(this.a.fromJS(value.pop()), p()));`,
      `>        return p() } }`,
      `>    );`,
      ``,
      `To summarise, \`\`this\`\` when coercing from reason.js is the array \`\`appliedTerms\`\`, whereas when coercing to reason.js it's a hash of the constructors plus the type parameters. Thanks to duplicate name checks at typecheck these names should not clash, but I may make the separation more clear cut at a later date.`
    ].join('\n'), [
      `let Bool = new R.Data(`,
      `      "Bool", "Type",`,
      `      [ { "F : Bool":`,
      `          { toString: () => 'F',`,
      `            valueOf: () => false } },`,
      `        { "T : Bool":`,
      `          { toString: () => 'T',`,
      `            valueOf: () => true } } ],`,
      `      { fromJS: value => Bool()[value ? 't' : 'f']() }`,
      `    ),`,
      ``,
      `    List = new R.Data(`,
      `      "List", "(A : Type) : Type",`,
      `      [ { "Nil : List A":`,
      `          { toString: () => '[]',`,
      `            valueOf: () => [] } },`,
      `        { "Cons : (x : A)(xs : List A) -> List A":`,
      `          { toString () {`,
      `            return '[ ' + (this[1].name === "Cons" ?`,
      `              this[0].toString() + ', ' +`,
      `                this[1].toString().slice(2) :`,
      `              this[0].toString() + ' ]') },`,
      `            valueOf () {`,
      `            return [ this[0].valueOf() ]`,
      `              .concat(this[1].valueOf()) } }`,
      `        } ],`,
      `      { fromJS (value) {`,
      `        let p = () => value.length === 0 ?`,
      `              this.nil() :`,
      `              this.cons(this.a.fromJS(value.shift()), p());`,
      `        return p() } }`,
      `    ),`,
      ``,
      `    nilBool = await new R.Def("nilBool", "Nil : List Bool").ready;`,
      ``,
      `let listBool = List(Bool());`,
      `log(nilBool.print, "--", nilBool.type.print())`,
      `log((await listBool.fromJS([true, false]).ready).toString())`
    ].join('\n'), true
    ],[[
      `#Indexed types#`,
      ``,
      `If parametrised types are where a strong typing system begins to reap benefits, indexed types are where dependent types start to shine. Now that you are a bit more familiar with the expression syntax, let's just jump into the canonical example of indexed types, vectors:`,
      ``,
      `>let Vec = new R.Data(`,
      `>      "Vec", "(A : Type) : Nat -> Type",`,
      `>      [ "Nil : Vec A Z",`,
      `>        "Cons : {n : Nat}`,
      `>                (x : A)`,
      `>                (xs : Vec A n) -> Vec A (S n)" ]`,
      `>    );`,
      ``,
      `One thing we can say is that it looks a lot like a list, but there is a lot to remark on. In the type constructor we can see vectors are parametrised over \`\`A\`\` meaning, like lists, they can contain terms of any type as long as they are the same. However, now there is what looks like a function on the right hand side. The index of this indexed type is the \`\`Nat\`\` part of the pi expression \`\`Nat -> Type\`\`. What this means is that a vector type is constructed with \`\`Vec A\`\`, but this time we don't have a single type. We have a //type family//. So to get a concrete value for the type, it requires another term of type \`\`Nat\`\` to be applied. In other words, \`\`A\`\` will never change, but the second argument can be different for different vector terms.`,
      ``,
      `Another thing which might have caught your attention is the fact that the term constructors don't just look like those of \`\`List\`\`, they are named exactly the same. I mentioned earlier that duplicate names are forbidden by the interpreter. So what gives? In fact, term constructors are an excption: since terms are typed, there is never any ambiguity if constructors of different types have the same name. You just can't name two term constructors for the same type the same.`,
      ``,
      `Lastly, what are those curly brackets at the start of the \`\`Cons\`\` definition? If you were to actually construct a \`\`Cons\`\` term, you would actually only need two arguments, for example: \`\`Cons TT Nil\`\` for a vector containing a single unit term. The term in braces is known as an //erased// term, and wherever you see braces in an expression, it means you are allowed to omit it if its concrete value is forced by other information. We can follow the value of \`\`n\`\` as the vector gets built: for \`\`Nil\`\` the value is \`\`Z\`\`, and at the first \`\`Cons\`\` any \`\`n\`\` becomes \`\`S n\`\`, so we get \`\`S Z\`\`. So \`\`n\`\` is pinned and does not need to be included. It //may// be included however, so it is perfectly valid to write \`\`Cons {Z} TT Nil\`\`, though you had better get your own calculation for the term correct!`,
      ``,
      `Or, this would be how it's supposed to work, except that I am still in the process of writing the unifier for reason.js, which is the part of the type checker that solves all the constraints involved with indexed types. For the moment, even valid functions on indexed types don't typecheck, and invalid signatures do, a lot of the time. This is top of the list of bugs to fix, because I am excited to start testing //equality types//, and add a new section here on proofs using those awesome indexed types.`
    ].join('\n'), [
      `let Bool = new R.Data(`,
      `      "Bool", "Type",`,
      `      [ "F : Bool",`,
      `        "T : Bool" ]`,
      `    ),`,
      ``,
      `    Nat = new R.Data(`,
      `      "Nat", "Type",`,
      `      [ "Z : Nat",`,
      `        "S : (n : Nat) -> Nat" ]`,
      `    ),`,
      ``,
      `    Vec = new R.Data(`,
      `      "Vec", "(A : Type) : Nat -> Type",`,
      `      [ "Nil : Vec A Z",`,
      `        "Cons : {n : Nat}" +`,
      `               "(x : A)" +`,
      `               "(xs : Vec A n) -> Vec A (S n)" ]`,
      `    ),`,
      ``,
      `    boolVec = new R.Def(`,
      `      "boolVec", "Cons T Nil : Vec Bool (S Z)"`,
      `    );`,
      ``,
      `await R.ready;`,
      ``,
      `log(boolVec.print, "--", boolVec.type.print())`
    ].join('\n'), true
    ], [[
      `#Case expressions#`,
      ``,
      `If you have been thinking about how to write a function on some of the types we've encountered so far, you may have realised that lambda expressions are somewhat hard to use. In fact, any function you like can be encoded with lambdas, but require something called an eliminator for each type. Eliminators pretty much suck to write, with the eliminator for even a type as simple as Booleans going on for many lines of dense code. Luckily there is a much simpler alternative: case expressions. Let's have a look at addition on \`\`Nat\`\` written using case syntax:`,
      ``,
      `>let plus = new R.Sig(`,
      `>      "plus", "Nat -> Nat -> Nat"`,
      `>    ).Def({`,
      `>      "x y | x":`,
      `>      [ "Z := y",`,
      `>        "S m := S (plus m y)" ]`,
      `>    });`,
      ``,
      `Here we can see the signature and definition being created in separate, chained methods - we promised to go into this usage back in the section on signature definitions, and I think you'll agree we have a lot more interesting terms at our disposal now. Addition is a binary operator, so the type expression \`\`Nat -> Nat -> Nat\`\` makes sense: two in, one out. Next we see the case syntax: a hash with one entry, with the key expressing the //scrutinee//, and the value an array of //clauses//.`,
      ``,
      `A scrutinee simply means the expression we would like to branch on, like the argument to a \`\`switch\`\` statement. Here, given two arguments to \`\`plus\`\`, \`\`x\`\` and \`\`y\`\`, we would like to do different things depending on the value of \`\`x\`\`. In fact, this term doesn't need to just be an argument to the function. You can scrutinise any term whatsoever you would like to construct, as long as it returns a term constructed from a datatype (in other words, no functions).`,
      ``,
      `The clauses here have a //pattern// on the left of the \`\`:=\`\` identifier, and an expression on the right. The pattern lists one possible value of the scrutinee, with variables in places that the concrete value is allowed to be flexible, and can be slotted into the expression on the right if the case matches on that pattern. If you don't need to use a slot, instead of giving it a name you can use the wildcard variable \`\`_\`\` - no two wildcards are necessarily equal to one another. Thus we can read our definition of \`\`plus\`\` as: if \`\`x\`\` is \`\`Z\`\`, return the \`\`y\`\`; however, if \`\`x\`\` is \`\`S m\`\` for some \`\`m\`\`, return the successor of \`\`plus m y\`\`. In many languages \`\`+\`\` is just given to us, but this is actually what it means to add two natural numbers!`,
      ``,
      `Unfortunately, there are a number of useful extensions to this functionality which I haven't gotten around to implementing yet. The API is suggestive of nested case statements, but this is still not possible. Sometimes when you use indexed types, one or more constructors are mathematically impossible - to encode this, I will need to write the code for //absurd// clauses and update the docs. Finally, sometimes locations in the pattern are forced to be certain values, similar to the requirement for erasing arguments described in the previous section - this requires what is known as an //inaccessible// pattern. These are second in line for bug removal, as well as potentially automating case splitting on multiple scrutinees. In the meantime, there is still a lot you can do with a single case statement!`
    ].join('\n'), [
      `let Nat = new R.Data(`,
      `      "Nat", "Type",`,
      `      [ "Z : Nat",`,
      `        "S : (n : Nat) -> Nat" ]`,
      `    ),`,
      ``,
      `    plus = new R.Sig(`,
      `      "plus", "Nat -> Nat -> Nat"`,
      `    ).Def({`,
      `      "x y | x":`,
      `      [ "Z := y",`,
      `        "S m := S (plus m y)" ]`,
      `    }),`,
      ``,
      `    onePlusOne = new R.Def(`,
      `      "onePlusOne", "plus (S Z) (S Z)"`,
      `    );`,
      ``,
      `await R.ready;`,
      ``,
      `log(onePlusOne.print, "--", onePlusOne.result.print())`
    ].join('\n'), true
    ], [[
      `#Mixfix operators#`,
      ``,
      `In the previous section we talked about addition, and I mentioned the \`\`+\`\` symbol used in other languages. Although being able to define such fundamental function ourselves is awesome, it really would be nice if we could use the same syntax for addition as those languages and what everyone is used to. Well, guess what? That's totally possible in reason.js! Let's revisit addition using a //mixfix// operator:`,
      ``,
      `>let plus = new R.Sig(`,
      `>      "_+_", "Nat -> Nat -> Nat"`,
      `>    ).Def({`,
      `>      "x y | x":`,
      `>      [ "Z := y",`,
      `>        "S m := S (m + y)" ]`,
      `>    });`,
      ``,
      `You can see the new \`\`+\`\` at work in the second case clause, but it looks different in the name field - what are those underscores for? Well, similar to the wildcard variable \`\`_\`\`, they encode slots for terms to occupy. Since \`\`_+_\`\` has two slots in its name, it is looking for two arguments, which matches its type signature. And just as lambda functions and even case expressions can be partially applied, so to can mixfixes. We can rewrite the \`\`addTwo\`\` function from the section on expression now in terms of \`\`_+_\`\`:`,
      ``,
      `>let addTwo = new R.Def("addTwo", "((S (S Z)) +_) : Nat -> Nat");`,
      ``,
      `In fact, you can even write \`\`((S (S Z)) +)\`\` in the term part, and the parser will know exactly what you mean! All I need is to implement builtins for numbers (and strings) and we will be at Haskell levels of tersity.`
    ].join('\n'), [
      `let List = new R.Data(`,
      `      "List", "(A : Type) : Type",`,
      `      [ "Nil : List A",`,
      `        "Cons : (x : A)(xs : List A) -> List A" ]`,
      `    ),`,
      ``,
      `    Nat = new R.Data(`,
      `      "Nat", "Type",`,
      `      [ "Z : Nat",`,
      `        "S : (n : Nat) -> Nat" ]`,
      `    ),`,
      ``,
      `    plus = new R.Sig(`,
      `      "_+_", "Nat -> Nat -> Nat"`,
      `    ).Def({`,
      `      "x y | x":`,
      `      [ "Z := y",`,
      `        "S m := S (m + y)" ]`,
      `    }),`,
      ``,
      `    listMap = new R.Sig(`,
      `      "listMap", "{A B : Type} -> (A -> B) -> List A -> List B"`,
      `    ).Def({`,
      `      "{A} {B} f xs | xs":`,
      `      [ "Nil := Nil",`,
      `        "Cons a as := Cons (f a) (listMap {A} {B} f as)" ]`,
      `    }),`,
      ``,
      `    allAddTwo = new R.Def(`,
      `      "allAddTwo",`,
      `        "(listMap {Nat} {Nat} ((S (S Z)) +)) : " +`,
      `        "List Nat -> List Nat"`,
      `    ),`,
      ``,
      `    someList = await new R.Def(`,
      `      "someList",`,
      `        "(allAddTwo (Cons (Z) (Cons (S Z) (Cons (Z) Nil)))) : " +`,
      `        "List Nat"`,
      `    ).ready;`,
      ``,
      `log(someList.result.print())`
    ].join('\n'), true
    ], [[
      `#The end... ?#`,
      ``,
      `Obviously there are some gaping flaws with the current state of this project, but work is continuing through heavy university courseload - hopefully by the time you read this it will be in better health! I have set myself a rather lofty goal of implementing cubical types by July, so look forward to some interesting developments on the journey there.`
    ].join('\n')]
  ]
});

// Events
$.targets({
  app: { 'load-editors' () {
    this.sections.forEach(([p, source, cutin]) => {
      let section = $.load('section', 'main')[0][0], body = $('body')[0];
      write(p, section);
      if (typeof source === 'string' && source.length) {
        $('iframe', section)[0].srcdoc = $('template#editor')[0].innerHTML.replace(/\[\]/g, source);
        if (cutin) $('aside', section)[0].classList.add('cut-in');
      } else $('aside', section)[0].remove();
      new IntersectionObserver(entries => entries.forEach(entry => {
        if (entry.intersectionRatio * section.clientHeight / window.innerHeight > .5) {
          $('aside.active').forEach(el => el.classList.remove('active'));
          $('aside', section)[0].classList.add('active')
        }
      }), { root: body, threshold: Array.from(Array(21), (_, i) => i / 20) }).observe(section);
      $.queries({'.expand': { click () {
        let loc = (scrollY - section.offsetTop) / section.clientHeight;
        $('.expand').forEach(el => el.dataset.active = '')
        $('.collapse').forEach(el => el.dataset.active = 'active');
        body.classList.add('expanded');
        $('main')[0].scrollTo(0, section.offsetTop + loc * section.clientHeight)
      } }, '.collapse': { click () {
        let loc = ($('main')[0].scrollTop - section.offsetTop) / section.clientHeight;
        $('.expand').forEach(el => el.dataset.active = 'active');
        $('.collapse').forEach(el => el.dataset.active = '');
        body.classList.remove('expanded');
        scrollTo(0, section.offsetTop + loc * section.clientHeight)
      } } }, section);
    })
  } }
});
app.emit('load-editors');

// Oh god. Very old markup code I had lying around

function write (raw, section) {
  //  **bold**  //italic//  ``monospaced``  [[link url]]  [[link url|link text]]
  //  >multiline quote (\>no quote)  ␣␣↵line break  ↵↵paragraph  #(#..)header#
  function escape (text) {
    var div = document.createElement("div");
    div.appendChild(document.createTextNode(text));
    return div.innerHTML
  }
  var r = escape(raw), newline = r.indexOf("\r\n") !== -1 ? "\r\n" : r.indexOf("\n") !== -1 ? "\n" : "";
  r = r
    .replace(new RegExp(" + " + newline, "g"), "<br />" + newline)
    .replace(/^(#{1,5})([^#]*)#/, function ($0, $1, $2) {
      var l = $1.length + 1;
      if (l === 2) {
        var slug = encodeURI( $2.replace(/\s+/g, "-").replace(/\*\*(.*)\*\*/g, "$1").replace(/``(.*)``/g, "$1")
          .replace(/^/," ").replace(/([^:])\/\/(((?!\/\/)[\s\S])*)\/\//gm, "$2").replace(/^ /,"")
          .replace(/\[\[([^\]|]*)\]\]/g, "$1").replace(/\[\[([^|]*)\|([^\]]*)\]\]/g, "$2")
          .replace(/[^\w\-.~!$&'()*+,;=:@]/g, "").toLowerCase() );
        return "<header><a class='hashlink' id='" + slug + "' href='#" + slug + "'></a><h2>" + $2 +
          "</h2></header>"
      } else return "<h" + l + ">" + $2 + "</h" + l + ">"
    })
    .replace(/``([^`]*)``/g, "<code>$1</code>")
    .replace(/\*\*([^*]*)\*\*/g, "<strong>$1</strong>")
    .replace(/^/," ").replace(/([^:])\/\/(((?!\/\/)[\s\S])*)\/\//gm, "$1<em>$2</em>").replace(/^ /,"")
    .replace(/\[\[([^\]|]*)\]\]/g, function ($0, $1) { return "<a href='" + $1.replace(/'/g, "&apos;") + "'>" + $1 + "</a>" })
    .replace(/\[\[([^|]*)\|([^\]]*)\]\]/g, function ($0, $1, $2) { return "<a href='" + $1.replace(/'/g, "&apos;") + "'>" + $2 + "</a>" });
  for (var p = (newline === "" ? [r] : r.split(newline + newline)), i = 0; i < p.length; i++) {
    p[i] = p[i]
      .replace(/^(?:&gt;)?( +)/gm, function (match) { return match.replace(/\s/g,"&nbsp;") })
      .split(newline)
        .reduce((a, x, tmp) => (tmp = x.match(/^&gt;(.*)$/)) ? (a[0].push(tmp[1]), a) : a[0].length ? [[], x].concat(a) : [[], x].concat(a.slice(1)), [[]])
        .reverse().map(arr => typeof arr === 'string' || !arr.length ? arr : `<blockquote>${arr.join('<br/>')}</blockquote>`).join(newline)
      .replace(/^\\&gt;/g, "&gt;");
    p[i] = p[i].replace(/([\s\S]+)/g, "<p>$1</p>")
  }
  section.innerHTML += p.join(newline);
}

$.queries({})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>
